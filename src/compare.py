#!/usr/bin/python python3

# Add submodules to path for importing
import sys, os
sys.path.append(os.path.abspath(os.path.join('..', 'FaultArm')))
sys.path.append(os.path.abspath(os.path.join('..', 'FaultFlipper')))

# import packages from pip
from utils import console

# import FaultArm packages
from Parser import Parser
from Parser import Instruction
from Analyzer import Analyzer

# import FaultFlipper packages
import src.cli
import src.binary_tools  
import src.enums  
import src.mapping  
import src.report_utils  
import src.source_to_asm_map  
import src.tracer  
import src.tui

def compare():
# FaultArm requires the ASM file
# FaultFlipper require the Binary file
    file = "FaultArm/dataset/op_0/manual/guillermo_branch_complex_insecure.s"
    fr_instructions : list[Instruction] = FaultArmParse(file)
    ff_instructions = list()
    FaultFlipperParse()

def FaultArmParse(file: str) -> list[Instruction]:
# Parse data with Parser obj
    with console.status("Parsing file...", spinner="line"):
        try:
            parsed_data = Parser(file, console)
        except (FileNotFoundError, IsADirectoryError):
            console.print(f"[bright_red]Error: File {args.file[0]} not found or not valid.[/bright_red]")
            exit(1)
    console.log(f"Architecture Detected: [bright_yellow]{parsed_data.arch.name}[/bright_yellow]\n")

# Analyze data with Analyzer to get vulnerability results
    with console.status("Analyzing parsed data...", spinner="line"):
        analyzed_data = Analyzer(file, parsed_data, parsed_data.total_lines, "./out/", console)    

# Get list of vulnerable instructions and their respective line numbers
    vuln_instructions = list()
    vuln_instructions.append(analyzed_data.constant_detector.vulnerable_instructions)
    vuln_instructions.append(analyzed_data.loop_detector.vulnerable_instructions)
    vuln_instructions.append(analyzed_data.branchV2_detector.vulnerable_instructions)
    vuln_instructions.append(analyzed_data.bypass_detector.vulnerable_set)
    return [
        instr
        for vuln_type in vuln_instructions 
            for instructions in vuln_type
                for instr in instructions
    ]


'''
FaultArm requires the ASM file
FaultFlipper require the Binary file

FaultFlipper runs off of the same ASM file generated by diasm()
so they both need to take in a binary and run based off of the disasm file
the only problem is that the disasm() doesnt return a clean file (OR DOES IT?)
'''
def FaultFlipperParse():
    text_section = disassemble_text_section("test_bin")
    print(text_section)
    pass

if __name__ == '__main__':
    compare()
